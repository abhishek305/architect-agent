import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';

/**
 * TDR Schema - Technical Design Review document structure
 * Forces the LLM to structure technical documents professionally
 */
export const TDRSchema = z.object({
  header: z.object({
    title: z.string(),
    status: z.enum(['Draft', 'Review', 'Approved']),
    author: z.string(),
  }),
  architecture: z.object({
    diagramDescription: z.string(), // Text description for Mermaid.js
    components: z.array(z.string()),
    dataFlow: z.string(),
  }),
  securityAudit: z.object({
    threatModel: z.string(),
    authentication: z.string(),
    dataPrivacy: z.string(),
  }),
  scalabilityPlan: z.object({
    bottlenecks: z.array(z.string()),
    monitoringStrategy: z.string(), // SLIs and SLOs
  }),
  implementationGuide: z.object({
    stepByStep: z.array(z.string()),
    commonPitfalls: z.array(z.string()), // For Junior/Mid devs
  }),
});

/**
 * PRD Schema - Product Requirements Document structure
 */
export const PRDSchema = z.object({
  header: z.object({
    title: z.string(),
    status: z.enum(['Draft', 'Review', 'Approved']),
    author: z.string(),
    version: z.string(),
  }),
  problemStatement: z.object({
    userPainPoints: z.array(z.string()),
    targetAudience: z.string(),
    businessContext: z.string(),
  }),
  goals: z.object({
    objectives: z.array(z.string()),
    successMetrics: z.array(z.string()),
    kpis: z.array(z.string()),
  }),
  requirements: z.object({
    mustHave: z.array(z.string()),
    shouldHave: z.array(z.string()),
    niceToHave: z.array(z.string()),
  }),
  userStories: z.array(z.object({
    persona: z.string(),
    story: z.string(),
    acceptanceCriteria: z.array(z.string()),
  })),
  timeline: z.object({
    phases: z.array(z.string()),
    milestones: z.array(z.string()),
  }),
});

export type TDRDocument = z.infer<typeof TDRSchema>;
export type PRDDocument = z.infer<typeof PRDSchema>;

/**
 * Generates a Mermaid.js architecture diagram from TDR components
 */
export function generateMermaidDiagram(components: string[], dataFlow: string): string {
  const componentNodes = components.map((comp, idx) => `    ${String.fromCharCode(65 + idx)}[${comp}]`).join('\n');
  
  return `\`\`\`mermaid
graph TB
    subgraph "System Architecture"
${componentNodes}
    end
    
    %% Data Flow
    %% ${dataFlow}
    
    %% Add your component connections below
    %% Example: A --> B
    %% Example: B --> C
\`\`\``;
}

/**
 * Formats a TDR document into Markdown
 */
export function formatTDRToMarkdown(tdr: TDRDocument): string {
  const mermaidDiagram = generateMermaidDiagram(tdr.architecture.components, tdr.architecture.dataFlow);
  
  return `# ${tdr.header.title}

**Status:** ${tdr.header.status}  
**Author:** ${tdr.header.author}  
**Generated:** ${new Date().toISOString().split('T')[0]}

---

## 1. Architecture Overview

### System Diagram

${mermaidDiagram}

### Architecture Description
${tdr.architecture.diagramDescription}

### Components
${tdr.architecture.components.map((c, i) => `${i + 1}. ${c}`).join('\n')}

### Data Flow
${tdr.architecture.dataFlow}

---

## 2. Security Audit

### Threat Model
${tdr.securityAudit.threatModel}

### Authentication & Authorization
${tdr.securityAudit.authentication}

### Data Privacy & PII Handling
${tdr.securityAudit.dataPrivacy}

---

## 3. Scalability Plan

### Identified Bottlenecks
${tdr.scalabilityPlan.bottlenecks.map((b, i) => `${i + 1}. ${b}`).join('\n')}

### Monitoring Strategy (SLIs/SLOs)
${tdr.scalabilityPlan.monitoringStrategy}

---

## 4. Implementation Guide

### Step-by-Step Instructions
${tdr.implementationGuide.stepByStep.map((s, i) => `${i + 1}. ${s}`).join('\n')}

### Common Pitfalls (Junior/Mid Dev Notes)
${tdr.implementationGuide.commonPitfalls.map((p, i) => `‚ö†Ô∏è **Pitfall ${i + 1}:** ${p}`).join('\n\n')}

---

*Document generated by Document Architect Agent*
`;
}

/**
 * Formats a PRD document into Markdown
 */
export function formatPRDToMarkdown(prd: PRDDocument): string {
  return `# ${prd.header.title}

**Status:** ${prd.header.status}  
**Author:** ${prd.header.author}  
**Version:** ${prd.header.version}  
**Generated:** ${new Date().toISOString().split('T')[0]}

---

## 1. Problem Statement

### User Pain Points
${prd.problemStatement.userPainPoints.map((p, i) => `${i + 1}. ${p}`).join('\n')}

### Target Audience
${prd.problemStatement.targetAudience}

### Business Context
${prd.problemStatement.businessContext}

---

## 2. Goals & Success Metrics

### Objectives
${prd.goals.objectives.map((o, i) => `${i + 1}. ${o}`).join('\n')}

### Success Metrics
${prd.goals.successMetrics.map((m, i) => `- ${m}`).join('\n')}

### Key Performance Indicators (KPIs)
${prd.goals.kpis.map((k, i) => `- ${k}`).join('\n')}

---

## 3. Requirements

### Must Have (P0)
${prd.requirements.mustHave.map((r, i) => `- [ ] ${r}`).join('\n')}

### Should Have (P1)
${prd.requirements.shouldHave.map((r, i) => `- [ ] ${r}`).join('\n')}

### Nice to Have (P2)
${prd.requirements.niceToHave.map((r, i) => `- [ ] ${r}`).join('\n')}

---

## 4. User Stories

${prd.userStories.map((story, i) => `### Story ${i + 1}: ${story.persona}

**As a** ${story.persona}, **I want** ${story.story}

**Acceptance Criteria:**
${story.acceptanceCriteria.map((c, j) => `- [ ] ${c}`).join('\n')}
`).join('\n')}

---

## 5. Timeline

### Phases
${prd.timeline.phases.map((p, i) => `${i + 1}. ${p}`).join('\n')}

### Milestones
${prd.timeline.milestones.map((m, i) => `- üéØ ${m}`).join('\n')}

---

*Document generated by Document Architect Agent*
`;
}

/**
 * Save Document Tool
 * Saves content to a file in the /docs folder
 */
export const saveDocumentTool = createTool({
  id: 'save-document',
  description: 'Saves a document (PRD or TDR) as a Markdown file to the /docs folder. Use this after gathering all interview responses to generate the final document.',
  inputSchema: z.object({
    filename: z.string().describe('The filename for the document (without extension, e.g., "user-auth-tdr")'),
    content: z.string().describe('The full Markdown content of the document to save'),
    documentType: z.enum(['PRD', 'TDR']).describe('The type of document being saved'),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    filePath: z.string(),
    message: z.string(),
  }),
  execute: async ({ context }) => {
    const { filename, content, documentType } = context;
    
    // Get the project root directory
    const projectRoot = process.cwd();
    const docsDir = path.join(projectRoot, 'docs');
    
    // Create docs directory if it doesn't exist
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
    }
    
    // Generate a timestamp for unique filenames
    const timestamp = new Date().toISOString().split('T')[0];
    const sanitizedFilename = filename.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
    const fullFilename = `${sanitizedFilename}-${timestamp}.md`;
    const filePath = path.join(docsDir, fullFilename);
    
    try {
      // Add document header metadata
      const header = `<!-- 
Document Type: ${documentType}
Generated: ${new Date().toISOString()}
Tool: Document Architect Agent
-->

`;
      
      fs.writeFileSync(filePath, header + content, 'utf-8');
      
      return {
        success: true,
        filePath: filePath,
        message: `‚úÖ ${documentType} saved successfully to: ${filePath}`,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      return {
        success: false,
        filePath: '',
        message: `‚ùå Failed to save document: ${errorMessage}`,
      };
    }
  },
});

/**
 * Generate Mermaid Diagram Tool
 * Creates a Mermaid.js diagram from component descriptions
 */
export const generateDiagramTool = createTool({
  id: 'generate-mermaid-diagram',
  description: 'Generates a Mermaid.js architecture diagram from a list of components and their relationships',
  inputSchema: z.object({
    diagramType: z.enum(['flowchart', 'sequence', 'class', 'er']).describe('Type of Mermaid diagram to generate'),
    title: z.string().describe('Title for the diagram'),
    components: z.array(z.object({
      id: z.string().describe('Unique identifier for the component (e.g., "API", "DB")'),
      label: z.string().describe('Display label for the component'),
      type: z.enum(['service', 'database', 'queue', 'cache', 'external', 'user']).optional(),
    })).describe('List of components in the architecture'),
    connections: z.array(z.object({
      from: z.string().describe('Source component ID'),
      to: z.string().describe('Target component ID'),
      label: z.string().optional().describe('Label for the connection'),
      type: z.enum(['solid', 'dashed', 'dotted']).optional(),
    })).describe('Connections between components'),
  }),
  outputSchema: z.object({
    mermaidCode: z.string(),
    diagramType: z.string(),
  }),
  execute: async ({ context }) => {
    const { diagramType, title, components, connections } = context;
    
    let mermaidCode = '';
    
    if (diagramType === 'flowchart') {
      mermaidCode = `\`\`\`mermaid
graph TB
    subgraph "${title}"
${components.map(c => {
  const shape = c.type === 'database' ? `[(${c.label})]` :
                c.type === 'queue' ? `{{${c.label}}}` :
                c.type === 'cache' ? `([${c.label}])` :
                c.type === 'external' ? `>${c.label}]` :
                c.type === 'user' ? `((${c.label}))` :
                `[${c.label}]`;
  return `        ${c.id}${shape}`;
}).join('\n')}
    end
    
${connections.map(conn => {
  const arrow = conn.type === 'dashed' ? '-.->' :
                conn.type === 'dotted' ? '-..->' :
                '-->';
  const label = conn.label ? `|${conn.label}|` : '';
  return `    ${conn.from} ${arrow}${label} ${conn.to}`;
}).join('\n')}
\`\`\``;
    } else if (diagramType === 'sequence') {
      mermaidCode = `\`\`\`mermaid
sequenceDiagram
    title ${title}
${components.map(c => `    participant ${c.id} as ${c.label}`).join('\n')}
    
${connections.map(conn => {
  const arrow = conn.type === 'dashed' ? '-->>' : '->>';
  return `    ${conn.from}${arrow}${conn.to}: ${conn.label || 'request'}`;
}).join('\n')}
\`\`\``;
    } else {
      // Default to flowchart for other types
      mermaidCode = `\`\`\`mermaid
graph LR
    subgraph "${title}"
${components.map(c => `        ${c.id}[${c.label}]`).join('\n')}
    end
${connections.map(conn => `    ${conn.from} --> ${conn.to}`).join('\n')}
\`\`\``;
    }
    
    return {
      mermaidCode,
      diagramType,
    };
  },
});

/**
 * Tech Stack Analyzer Tool
 * Analyzes mentioned technologies and provides recommendations
 */
export const analyzeStackTool = createTool({
  id: 'analyze-tech-stack',
  description: 'Analyzes the tech stack mentioned in the conversation and provides tailored recommendations, best practices, and common pitfalls',
  inputSchema: z.object({
    technologies: z.array(z.string()).describe('List of technologies mentioned (e.g., ["React", "Node.js", "PostgreSQL"])'),
    useCase: z.enum(['web', 'mobile', 'api', 'data-pipeline', 'ml', 'microservices', 'monolith']).describe('The type of application being built'),
    scale: z.enum(['startup', 'growth', 'enterprise']).describe('Expected scale of the application'),
  }),
  outputSchema: z.object({
    analysis: z.object({
      strengths: z.array(z.string()),
      concerns: z.array(z.string()),
      recommendations: z.array(z.string()),
    }),
    bestPractices: z.array(z.object({
      technology: z.string(),
      practices: z.array(z.string()),
    })),
    commonPitfalls: z.array(z.object({
      technology: z.string(),
      pitfall: z.string(),
      solution: z.string(),
    })),
    resources: z.array(z.object({
      title: z.string(),
      url: z.string(),
      type: z.enum(['documentation', 'tutorial', 'article', 'video']),
    })),
  }),
  execute: async ({ context }) => {
    const { technologies, useCase, scale } = context;
    
    // Tech stack knowledge base
    const techKnowledge: Record<string, {
      strengths: string[];
      concerns: string[];
      practices: string[];
      pitfalls: { pitfall: string; solution: string }[];
      resources: { title: string; url: string; type: 'documentation' | 'tutorial' | 'article' | 'video' }[];
    }> = {
      'react': {
        strengths: ['Large ecosystem', 'Component reusability', 'Strong community'],
        concerns: ['Bundle size if not optimized', 'Learning curve for hooks'],
        practices: [
          'Use React.memo() for expensive components',
          'Implement code splitting with React.lazy()',
          'Use useCallback/useMemo for referential stability',
          'Keep components small and focused',
        ],
        pitfalls: [
          { pitfall: 'Creating new objects/arrays in render', solution: 'Use useMemo or move to state' },
          { pitfall: 'Missing dependency array in useEffect', solution: 'Always specify dependencies, use ESLint plugin' },
        ],
        resources: [
          { title: 'React Documentation', url: 'https://react.dev', type: 'documentation' },
          { title: 'React Performance', url: 'https://react.dev/learn/render-and-commit', type: 'tutorial' },
        ],
      },
      'node.js': {
        strengths: ['Non-blocking I/O', 'Same language as frontend', 'NPM ecosystem'],
        concerns: ['Single-threaded (CPU-bound tasks)', 'Callback complexity'],
        practices: [
          'Use async/await over callbacks',
          'Implement proper error handling with try/catch',
          'Use worker threads for CPU-intensive tasks',
          'Always validate and sanitize inputs',
        ],
        pitfalls: [
          { pitfall: 'Blocking the event loop', solution: 'Use worker threads or offload to queue' },
          { pitfall: 'Memory leaks from unclosed connections', solution: 'Implement proper cleanup in finally blocks' },
        ],
        resources: [
          { title: 'Node.js Best Practices', url: 'https://github.com/goldbergyoni/nodebestpractices', type: 'article' },
          { title: 'Node.js Documentation', url: 'https://nodejs.org/docs', type: 'documentation' },
        ],
      },
      'postgresql': {
        strengths: ['ACID compliance', 'Advanced features (JSONB, full-text search)', 'Extensibility'],
        concerns: ['Requires tuning for high scale', 'Write-heavy workloads need optimization'],
        practices: [
          'Use connection pooling (PgBouncer)',
          'Create indexes for frequently queried columns',
          'Use EXPLAIN ANALYZE to optimize queries',
          'Implement proper backup and recovery',
        ],
        pitfalls: [
          { pitfall: 'Missing indexes on foreign keys', solution: 'Always index FK columns' },
          { pitfall: 'N+1 queries from ORM', solution: 'Use eager loading or raw queries' },
        ],
        resources: [
          { title: 'PostgreSQL Documentation', url: 'https://www.postgresql.org/docs/', type: 'documentation' },
          { title: 'Use The Index, Luke', url: 'https://use-the-index-luke.com/', type: 'tutorial' },
        ],
      },
      'typescript': {
        strengths: ['Type safety', 'Better IDE support', 'Catch errors at compile time'],
        concerns: ['Build step required', 'Learning curve for complex types'],
        practices: [
          'Enable strict mode in tsconfig',
          'Use branded types for IDs',
          'Prefer unknown over any',
          'Use discriminated unions for state',
        ],
        pitfalls: [
          { pitfall: 'Overusing any type', solution: 'Use unknown and type guards instead' },
          { pitfall: 'Type assertions without validation', solution: 'Use Zod or io-ts for runtime validation' },
        ],
        resources: [
          { title: 'TypeScript Handbook', url: 'https://www.typescriptlang.org/docs/handbook/', type: 'documentation' },
          { title: 'Total TypeScript', url: 'https://www.totaltypescript.com/', type: 'tutorial' },
        ],
      },
      'redis': {
        strengths: ['Extremely fast', 'Versatile data structures', 'Pub/sub support'],
        concerns: ['Memory bound', 'Data persistence trade-offs'],
        practices: [
          'Set appropriate TTLs for cache entries',
          'Use pipelining for batch operations',
          'Implement cache-aside pattern',
          'Monitor memory usage',
        ],
        pitfalls: [
          { pitfall: 'Cache stampede on expiry', solution: 'Use probabilistic early recomputation' },
          { pitfall: 'Storing large objects', solution: 'Compress or split across keys' },
        ],
        resources: [
          { title: 'Redis Documentation', url: 'https://redis.io/docs/', type: 'documentation' },
          { title: 'Redis Best Practices', url: 'https://redis.io/docs/management/optimization/', type: 'article' },
        ],
      },
    };
    
    // Analyze the stack
    const strengths: string[] = [];
    const concerns: string[] = [];
    const recommendations: string[] = [];
    const bestPractices: { technology: string; practices: string[] }[] = [];
    const commonPitfalls: { technology: string; pitfall: string; solution: string }[] = [];
    const resources: { title: string; url: string; type: 'documentation' | 'tutorial' | 'article' | 'video' }[] = [];
    
    for (const tech of technologies) {
      const techLower = tech.toLowerCase();
      const knowledge = techKnowledge[techLower];
      
      if (knowledge) {
        strengths.push(...knowledge.strengths.map(s => `${tech}: ${s}`));
        concerns.push(...knowledge.concerns.map(c => `${tech}: ${c}`));
        bestPractices.push({ technology: tech, practices: knowledge.practices });
        commonPitfalls.push(...knowledge.pitfalls.map(p => ({ technology: tech, ...p })));
        resources.push(...knowledge.resources);
      }
    }
    
    // Add scale-specific recommendations
    if (scale === 'startup') {
      recommendations.push('Focus on developer velocity over optimization');
      recommendations.push('Use managed services (RDS, ElastiCache) to reduce ops burden');
      recommendations.push('Implement feature flags for safe deployments');
    } else if (scale === 'growth') {
      recommendations.push('Implement comprehensive monitoring and alerting');
      recommendations.push('Add caching layer to reduce database load');
      recommendations.push('Consider read replicas for database');
    } else if (scale === 'enterprise') {
      recommendations.push('Implement multi-region deployment for DR');
      recommendations.push('Add comprehensive audit logging');
      recommendations.push('Consider service mesh for microservices');
    }
    
    // Add use-case specific recommendations
    if (useCase === 'api') {
      recommendations.push('Implement rate limiting and throttling');
      recommendations.push('Add request validation with Zod or Joi');
      recommendations.push('Use OpenAPI for documentation');
    } else if (useCase === 'web') {
      recommendations.push('Implement SSR or SSG for SEO');
      recommendations.push('Use CDN for static assets');
      recommendations.push('Add performance monitoring (Web Vitals)');
    }
    
    return {
      analysis: {
        strengths: strengths.slice(0, 10),
        concerns: concerns.slice(0, 5),
        recommendations,
      },
      bestPractices,
      commonPitfalls,
      resources: resources.slice(0, 10),
    };
  },
});

/**
 * Export Document Tool
 * Exports documents to different formats (HTML, Confluence, Notion)
 */
export const exportDocumentTool = createTool({
  id: 'export-document',
  description: 'Exports a document to different formats (HTML, Confluence wiki markup, or Notion)',
  inputSchema: z.object({
    content: z.string().describe('The markdown content to export'),
    format: z.enum(['html', 'confluence', 'notion']).describe('Target format for export'),
    filename: z.string().describe('Base filename for the exported file'),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    exportedContent: z.string(),
    filePath: z.string().optional(),
    message: z.string(),
  }),
  execute: async ({ context }) => {
    const { content, format, filename } = context;
    
    let exportedContent = '';
    let extension = '';
    
    switch (format) {
      case 'html':
        exportedContent = convertMarkdownToHtml(content);
        extension = 'html';
        break;
        
      case 'confluence':
        exportedContent = convertToConfluence(content);
        extension = 'txt';
        break;
        
      case 'notion':
        exportedContent = convertToNotion(content);
        extension = 'md';
        break;
    }
    
    // Save the exported file
    const projectRoot = process.cwd();
    const docsDir = path.join(projectRoot, 'docs', 'exports');
    
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().split('T')[0];
    const sanitizedFilename = filename.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
    const fullFilename = `${sanitizedFilename}-${format}-${timestamp}.${extension}`;
    const filePath = path.join(docsDir, fullFilename);
    
    try {
      fs.writeFileSync(filePath, exportedContent, 'utf-8');
      
      return {
        success: true,
        exportedContent,
        filePath,
        message: `‚úÖ Document exported to ${format} format: ${filePath}`,
      };
    } catch (error) {
      return {
        success: false,
        exportedContent,
        message: `‚ùå Failed to save exported file: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  },
});

/**
 * Convert markdown to HTML with inline styles
 */
function convertMarkdownToHtml(markdown: string): string {
  let html = markdown;
  
  // Headers
  html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
  html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
  html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
  
  // Bold
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  
  // Italic
  html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
  
  // Code blocks
  html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
  
  // Inline code
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
  
  // Lists
  html = html.replace(/^\- \[ \] (.*$)/gim, '<li><input type="checkbox"> $1</li>');
  html = html.replace(/^\- \[x\] (.*$)/gim, '<li><input type="checkbox" checked> $1</li>');
  html = html.replace(/^\- (.*$)/gim, '<li>$1</li>');
  
  // Links
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
  
  // Tables (basic)
  html = html.replace(/\|(.+)\|/g, (match, content) => {
    const cells = content.split('|').map((cell: string) => `<td>${cell.trim()}</td>`).join('');
    return `<tr>${cells}</tr>`;
  });
  
  // Horizontal rules
  html = html.replace(/^---$/gim, '<hr>');
  
  const styles = `
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 0 auto; padding: 2rem; line-height: 1.6; }
  h1 { color: #1a1a1a; border-bottom: 2px solid #e5e5e5; padding-bottom: 0.5rem; }
  h2 { color: #2a2a2a; margin-top: 2rem; }
  h3 { color: #3a3a3a; }
  code { background: #f4f4f4; padding: 0.2rem 0.4rem; border-radius: 3px; font-size: 0.9em; }
  pre { background: #1e1e1e; color: #d4d4d4; padding: 1rem; border-radius: 8px; overflow-x: auto; }
  pre code { background: none; padding: 0; }
  table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
  th, td { border: 1px solid #ddd; padding: 0.75rem; text-align: left; }
  th { background: #f5f5f5; }
  li { margin: 0.25rem 0; }
</style>`;

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  ${styles}
</head>
<body>
  ${html}
</body>
</html>`;
}

/**
 * Convert markdown to Confluence wiki markup
 */
function convertToConfluence(markdown: string): string {
  let wiki = markdown;
  
  // Headers
  wiki = wiki.replace(/^### (.*$)/gim, 'h3. $1');
  wiki = wiki.replace(/^## (.*$)/gim, 'h2. $1');
  wiki = wiki.replace(/^# (.*$)/gim, 'h1. $1');
  
  // Bold
  wiki = wiki.replace(/\*\*(.*?)\*\*/g, '*$1*');
  
  // Italic
  wiki = wiki.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '_$1_');
  
  // Code blocks
  wiki = wiki.replace(/```(\w+)?\n([\s\S]*?)```/g, '{code:$1}\n$2{code}');
  
  // Inline code
  wiki = wiki.replace(/`([^`]+)`/g, '{{$1}}');
  
  // Lists
  wiki = wiki.replace(/^\- \[ \] (.*$)/gim, '* (x) $1');
  wiki = wiki.replace(/^\- \[x\] (.*$)/gim, '* (/) $1');
  wiki = wiki.replace(/^\- (.*$)/gim, '* $1');
  
  // Links
  wiki = wiki.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '[$1|$2]');
  
  // Tables
  wiki = wiki.replace(/\|(.+)\|/g, (match, content) => {
    return `||${content.split('|').join('||')}||`;
  });
  
  // Horizontal rules
  wiki = wiki.replace(/^---$/gim, '----');
  
  return wiki;
}

/**
 * Convert markdown for Notion (minor adjustments for callouts)
 */
function convertToNotion(markdown: string): string {
  let notion = markdown;
  
  // Convert tips and warnings to callout format
  notion = notion.replace(/üí° \*\*Tip:\*\*/g, '> üí° **Tip:**');
  notion = notion.replace(/‚ö†Ô∏è \*\*Warning:\*\*/g, '> ‚ö†Ô∏è **Warning:**');
  notion = notion.replace(/üîí \*\*Junior Dev Note:\*\*/g, '> üéì **Junior Dev Note:**');
  
  return notion;
}
