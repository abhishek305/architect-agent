import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';

/**
 * TDR Schema - Technical Design Review document structure
 * Forces the LLM to structure technical documents professionally
 */
export const TDRSchema = z.object({
  header: z.object({
    title: z.string(),
    status: z.enum(['Draft', 'Review', 'Approved']),
    author: z.string(),
  }),
  architecture: z.object({
    diagramDescription: z.string(), // Text description for Mermaid.js
    components: z.array(z.string()),
    dataFlow: z.string(),
  }),
  securityAudit: z.object({
    threatModel: z.string(),
    authentication: z.string(),
    dataPrivacy: z.string(),
  }),
  scalabilityPlan: z.object({
    bottlenecks: z.array(z.string()),
    monitoringStrategy: z.string(), // SLIs and SLOs
  }),
  implementationGuide: z.object({
    stepByStep: z.array(z.string()),
    commonPitfalls: z.array(z.string()), // For Junior/Mid devs
  }),
});

/**
 * PRD Schema - Product Requirements Document structure
 */
export const PRDSchema = z.object({
  header: z.object({
    title: z.string(),
    status: z.enum(['Draft', 'Review', 'Approved']),
    author: z.string(),
    version: z.string(),
  }),
  problemStatement: z.object({
    userPainPoints: z.array(z.string()),
    targetAudience: z.string(),
    businessContext: z.string(),
  }),
  goals: z.object({
    objectives: z.array(z.string()),
    successMetrics: z.array(z.string()),
    kpis: z.array(z.string()),
  }),
  requirements: z.object({
    mustHave: z.array(z.string()),
    shouldHave: z.array(z.string()),
    niceToHave: z.array(z.string()),
  }),
  userStories: z.array(z.object({
    persona: z.string(),
    story: z.string(),
    acceptanceCriteria: z.array(z.string()),
  })),
  timeline: z.object({
    phases: z.array(z.string()),
    milestones: z.array(z.string()),
  }),
});

export type TDRDocument = z.infer<typeof TDRSchema>;
export type PRDDocument = z.infer<typeof PRDSchema>;

/**
 * Generates a Mermaid.js architecture diagram from TDR components
 */
export function generateMermaidDiagram(components: string[], dataFlow: string): string {
  const componentNodes = components.map((comp, idx) => `    ${String.fromCharCode(65 + idx)}[${comp}]`).join('\n');
  
  return `\`\`\`mermaid
graph TB
    subgraph "System Architecture"
${componentNodes}
    end
    
    %% Data Flow
    %% ${dataFlow}
    
    %% Add your component connections below
    %% Example: A --> B
    %% Example: B --> C
\`\`\``;
}

/**
 * Formats a TDR document into Markdown
 */
export function formatTDRToMarkdown(tdr: TDRDocument): string {
  const mermaidDiagram = generateMermaidDiagram(tdr.architecture.components, tdr.architecture.dataFlow);
  
  return `# ${tdr.header.title}

**Status:** ${tdr.header.status}  
**Author:** ${tdr.header.author}  
**Generated:** ${new Date().toISOString().split('T')[0]}

---

## 1. Architecture Overview

### System Diagram

${mermaidDiagram}

### Architecture Description
${tdr.architecture.diagramDescription}

### Components
${tdr.architecture.components.map((c, i) => `${i + 1}. ${c}`).join('\n')}

### Data Flow
${tdr.architecture.dataFlow}

---

## 2. Security Audit

### Threat Model
${tdr.securityAudit.threatModel}

### Authentication & Authorization
${tdr.securityAudit.authentication}

### Data Privacy & PII Handling
${tdr.securityAudit.dataPrivacy}

---

## 3. Scalability Plan

### Identified Bottlenecks
${tdr.scalabilityPlan.bottlenecks.map((b, i) => `${i + 1}. ${b}`).join('\n')}

### Monitoring Strategy (SLIs/SLOs)
${tdr.scalabilityPlan.monitoringStrategy}

---

## 4. Implementation Guide

### Step-by-Step Instructions
${tdr.implementationGuide.stepByStep.map((s, i) => `${i + 1}. ${s}`).join('\n')}

### Common Pitfalls (Junior/Mid Dev Notes)
${tdr.implementationGuide.commonPitfalls.map((p, i) => `âš ï¸ **Pitfall ${i + 1}:** ${p}`).join('\n\n')}

---

*Document generated by Document Architect Agent*
`;
}

/**
 * Formats a PRD document into Markdown
 */
export function formatPRDToMarkdown(prd: PRDDocument): string {
  return `# ${prd.header.title}

**Status:** ${prd.header.status}  
**Author:** ${prd.header.author}  
**Version:** ${prd.header.version}  
**Generated:** ${new Date().toISOString().split('T')[0]}

---

## 1. Problem Statement

### User Pain Points
${prd.problemStatement.userPainPoints.map((p, i) => `${i + 1}. ${p}`).join('\n')}

### Target Audience
${prd.problemStatement.targetAudience}

### Business Context
${prd.problemStatement.businessContext}

---

## 2. Goals & Success Metrics

### Objectives
${prd.goals.objectives.map((o, i) => `${i + 1}. ${o}`).join('\n')}

### Success Metrics
${prd.goals.successMetrics.map((m, i) => `- ${m}`).join('\n')}

### Key Performance Indicators (KPIs)
${prd.goals.kpis.map((k, i) => `- ${k}`).join('\n')}

---

## 3. Requirements

### Must Have (P0)
${prd.requirements.mustHave.map((r, i) => `- [ ] ${r}`).join('\n')}

### Should Have (P1)
${prd.requirements.shouldHave.map((r, i) => `- [ ] ${r}`).join('\n')}

### Nice to Have (P2)
${prd.requirements.niceToHave.map((r, i) => `- [ ] ${r}`).join('\n')}

---

## 4. User Stories

${prd.userStories.map((story, i) => `### Story ${i + 1}: ${story.persona}

**As a** ${story.persona}, **I want** ${story.story}

**Acceptance Criteria:**
${story.acceptanceCriteria.map((c, j) => `- [ ] ${c}`).join('\n')}
`).join('\n')}

---

## 5. Timeline

### Phases
${prd.timeline.phases.map((p, i) => `${i + 1}. ${p}`).join('\n')}

### Milestones
${prd.timeline.milestones.map((m, i) => `- ðŸŽ¯ ${m}`).join('\n')}

---

*Document generated by Document Architect Agent*
`;
}

/**
 * Save Document Tool
 * Saves content to a file in the /docs folder
 */
export const saveDocumentTool = createTool({
  id: 'save-document',
  description: 'Saves a document (PRD or TDR) as a Markdown file to the /docs folder. Use this after gathering all interview responses to generate the final document.',
  inputSchema: z.object({
    filename: z.string().describe('The filename for the document (without extension, e.g., "user-auth-tdr")'),
    content: z.string().describe('The full Markdown content of the document to save'),
    documentType: z.enum(['PRD', 'TDR']).describe('The type of document being saved'),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    filePath: z.string(),
    message: z.string(),
  }),
  execute: async ({ context }) => {
    const { filename, content, documentType } = context;
    
    // Get the project root directory
    const projectRoot = process.cwd();
    const docsDir = path.join(projectRoot, 'docs');
    
    // Create docs directory if it doesn't exist
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
    }
    
    // Generate a timestamp for unique filenames
    const timestamp = new Date().toISOString().split('T')[0];
    const sanitizedFilename = filename.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
    const fullFilename = `${sanitizedFilename}-${timestamp}.md`;
    const filePath = path.join(docsDir, fullFilename);
    
    try {
      // Add document header metadata
      const header = `<!-- 
Document Type: ${documentType}
Generated: ${new Date().toISOString()}
Tool: Document Architect Agent
-->

`;
      
      fs.writeFileSync(filePath, header + content, 'utf-8');
      
      return {
        success: true,
        filePath: filePath,
        message: `âœ… ${documentType} saved successfully to: ${filePath}`,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      return {
        success: false,
        filePath: '',
        message: `âŒ Failed to save document: ${errorMessage}`,
      };
    }
  },
});

/**
 * Generate Mermaid Diagram Tool
 * Creates a Mermaid.js diagram from component descriptions
 */
export const generateDiagramTool = createTool({
  id: 'generate-mermaid-diagram',
  description: 'Generates a Mermaid.js architecture diagram from a list of components and their relationships',
  inputSchema: z.object({
    diagramType: z.enum(['flowchart', 'sequence', 'class', 'er']).describe('Type of Mermaid diagram to generate'),
    title: z.string().describe('Title for the diagram'),
    components: z.array(z.object({
      id: z.string().describe('Unique identifier for the component (e.g., "API", "DB")'),
      label: z.string().describe('Display label for the component'),
      type: z.enum(['service', 'database', 'queue', 'cache', 'external', 'user']).optional(),
    })).describe('List of components in the architecture'),
    connections: z.array(z.object({
      from: z.string().describe('Source component ID'),
      to: z.string().describe('Target component ID'),
      label: z.string().optional().describe('Label for the connection'),
      type: z.enum(['solid', 'dashed', 'dotted']).optional(),
    })).describe('Connections between components'),
  }),
  outputSchema: z.object({
    mermaidCode: z.string(),
    diagramType: z.string(),
  }),
  execute: async ({ context }) => {
    const { diagramType, title, components, connections } = context;
    
    let mermaidCode = '';
    
    if (diagramType === 'flowchart') {
      mermaidCode = `\`\`\`mermaid
graph TB
    subgraph "${title}"
${components.map(c => {
  const shape = c.type === 'database' ? `[(${c.label})]` :
                c.type === 'queue' ? `{{${c.label}}}` :
                c.type === 'cache' ? `([${c.label}])` :
                c.type === 'external' ? `>${c.label}]` :
                c.type === 'user' ? `((${c.label}))` :
                `[${c.label}]`;
  return `        ${c.id}${shape}`;
}).join('\n')}
    end
    
${connections.map(conn => {
  const arrow = conn.type === 'dashed' ? '-.->' :
                conn.type === 'dotted' ? '-..->' :
                '-->';
  const label = conn.label ? `|${conn.label}|` : '';
  return `    ${conn.from} ${arrow}${label} ${conn.to}`;
}).join('\n')}
\`\`\``;
    } else if (diagramType === 'sequence') {
      mermaidCode = `\`\`\`mermaid
sequenceDiagram
    title ${title}
${components.map(c => `    participant ${c.id} as ${c.label}`).join('\n')}
    
${connections.map(conn => {
  const arrow = conn.type === 'dashed' ? '-->>' : '->>';
  return `    ${conn.from}${arrow}${conn.to}: ${conn.label || 'request'}`;
}).join('\n')}
\`\`\``;
    } else {
      // Default to flowchart for other types
      mermaidCode = `\`\`\`mermaid
graph LR
    subgraph "${title}"
${components.map(c => `        ${c.id}[${c.label}]`).join('\n')}
    end
${connections.map(conn => `    ${conn.from} --> ${conn.to}`).join('\n')}
\`\`\``;
    }
    
    return {
      mermaidCode,
      diagramType,
    };
  },
});
